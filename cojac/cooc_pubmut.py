#!/usr/bin/env python3
import numpy as np
import pandas as pd
import os

# import re
import argparse
import csv
import json
import yaml
import gzip


def main():
    # parse command line
    argparser = argparse.ArgumentParser(
        description="make a pretty table",
        epilog="you need to open the CSV in a spreadsheet that understands linebreaks",
    )
    inputgroup = argparser.add_mutually_exclusive_group(required=True)
    inputgroup.add_argument(
        "-j",
        "--json",
        metavar="JSON",
        type=str,
        dest="json",
        help="results generated by mutbamscan",
    )
    inputgroup.add_argument(
        "-y",
        "--yaml",
        metavar="YAML",
        type=str,
        dest="yaml",
        help="results generated by mutbamscan",
    )
    argparser.add_argument(
        "-o",
        "--output",
        metavar="CSV",
        required=False,
        default="scanned_article.csv",
        type=str,
        dest="csv",
        help="name of (pretty) csv file to save the table into",
    )
    dialectgroup = argparser.add_mutually_exclusive_group()
    dialectgroup.add_argument(
        "-e",
        "--escape",
        action="store_const",
        const=("\\n", csv.QUOTE_NONNUMERIC, "\\"),
        default=("\n", csv.QUOTE_MINIMAL, None),
        dest="escape",
        help="use escape characters for newlines",
    )
    dialectgroup.add_argument(
        "-x",
        "--excel",
        action="store_true",
        dest="semi",
        help="use a semi-colon ';' instead of a comma ',' in the comma-separated-files as required by Microsoft Excel",
    )
    argparser.add_argument(
        "-/",
        "--batchname",
        nargs="?",
        const="/",
        default=None,
        dest="batchname",
        help="split samplename/batchname (as in samples tsv)",
    )
    argparser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        dest="quiet",
        help="Run quietly: do not print the table",
    )
    args = argparser.parse_args()

    # load table
    table = {}

    assert not (
        args.semi and args.csv.rfind(".tsv") != -1
    ), f"Excel cannot use TSV files {args.csv}"

    if args.json:
        assert os.path.isfile(args.json), f"cannot find result json file {args.json}"
        with open(args.json, "rt") as jf:
            table = json.load(fp=jf)
    elif args.yaml:
        assert os.path.isfile(args.yaml), f"cannot find result json file {args.yaml}"
        with open(args.yaml, "rt") as yf:
            table = yaml.safe_load(yf)

    assert len(table) > 0, "cannot succesfully load table"

    #
    # pretty output for article
    #

    df_dict = {}
    for sam, amplicons in table.items():
        print(sam)
        # table key
        ksam = None
        if args.batchname:
            (sam, ignore, batch) = sam.rpartition(args.batchname)
            ksam = (sam, batch)
        else:
            ksam = sam
        df_dict[ksam] = {}

        for ampname, amp in amplicons.items():
            # get topmost
            sites_cnt_l = -1
            sites_cnt = 0
            if amp["sites"]:  # empty ?
                (sites_cnt_l, sites_cnt) = list(amp["sites"].items())[-1]
            muts_cnt_l = -1
            muts_cnt = 0
            if amp["muts"]:  # empty ?
                (muts_cnt_l, muts_cnt) = list(amp["muts"].items())[-1]

            if int(muts_cnt_l) < int(sites_cnt_l):
                muts_cnt = 0

            # pack into dict for pandas
            df_dict[ksam].update(
                {
                    ampname: f"{muts_cnt} / {sites_cnt}{args.escape[0]}{f'{100*float(muts_cnt)/float(sites_cnt) :.2f}%' if sites_cnt else 'NA'}"
                }
            )

    pretty_table_df = pd.DataFrame.from_dict(data=df_dict, orient="index")
    # TODO rename column with pretty names. (like in colourmut)
    if not args.quiet:
        with pd.option_context(
            "display.max_rows", None
        ):  # , 'display.max_columns', None):
            print(pretty_table_df)
    pretty_table_df.to_csv(
        args.csv,
        quoting=args.escape[1],
        escapechar=args.escape[2],
        sep=("\t" if args.csv.rfind(".tsv") != -1 else ";" if args.semi else ","),
        compression={"method": "infer"},
    )


if __name__ == "__main__":
    main()
